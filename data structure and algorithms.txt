==================== Evaluating Coding Ability ============================
1. Take-home assignment
2. Pair programming at a computer
3. Whiteboarding

npm install -g jest

jest fib/test.js --watch

==================== Reverse String ============================
node inspect index.js

==================== Palindrome ============================
Array Helper: Array.prototype.every();

function isBelowThreshold(currentValue) {
  return currentValue < 40;
}

var array1 = [1, 30, 39, 29, 10, 13];

console.log(array1.every(isBelowThreshold));
// expected output: true

==================== Integer Reversal ============================
Math.sign()

Math.sign(3);     //  1
Math.sign(-3);    // -1
Math.sign('-3');  // -1
Math.sign(0);     //  0
Math.sign(-0);    // -0
Math.sign(NaN);   // NaN
Math.sign('foo'); // NaN
Math.sign();      // NaN

convert a string to a number parseInt('string number')

==================== Max Chars ============================

for of : It is used FOR iterating  an array or string, or array of objects;
for in: specifically for objects

==================== The classic Fizz Buzz ============================

==================== Array Chunking ============================
slice method 

==================== Anagrams ============================
https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/RegExp
RegExp: Regular Expressions

const word = "HI THERE !!!!!";
word.replace(/[^\w]/g, "") //Replace the spaces no spaces

==================== Sentence Capitalization ============================
https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/String/slice

str.slice(beginIndex[, endIndex])

El siguiente ejemplo usa slice() para crear una nueva cadena.

var cadena1 = "La mañana se nos echa encima.";
var cadena2 = cadena1.slice(3, -2);
console.log(cadena2);
Esto escribe:

mañana se nos echa encim

==================== Printing Steps ============================


==================== Find the vowels ============================
word.includes("o");

function vowels(str) {
   // g: dont stop in the first match
   // i: insensitive cases lowerCase and upperCase
   const matches = str.match(/[aeiou]/gi);
   return matches ? matches.length : 0;
}

==================== Enter the Matrix Spiral ============================

Try to do it by yourself again

==================== Runtime Complexity ============================
Describes the performance of an algorithm
How much more processing power/time is required to run your algorithm if we double the inputs?

LINEAR RUNTIME: There is a direct one to one relationship between the number of input elements and the amount of work that 
it needs to be processed 

An example of linear runtime could be the Reverse algorithm

N TIMES COMPLEXITY OR CUADRATIC COMPLEXITY: The Steps algorithm is an example of this type of runtime 


Runtime Types:


Constant Time  1 : No matter how many elements we are working with, the algorithm/operation/whatever will always
                   take the same amount of time;

Logaritmic Time log(n) : You have this is doubling the number of elements you are iterating over does not double the amount
                         of work . Always assume that searching operations are log(n)

Linear Time n : Iterating throughall elements in a collection of data.  If you see a for loop spanning from '0' to 'array.length',
                you probably have 'n', or linear runtime.

Quasilinear Time n * log(n) : You have this if doubling the number of elements you are iterating over does not double the amount 
                              of work. Always assume that any sorting operation is n*log(n)

Quadratic Time n ^ 2 : Every element in a collection has to be compared to every other element. 'The handshake problem'

Exponential Time 2 ^ n : If you add a "single" element to a collection, the processing power required doubles



-------------------------------------------------
Big 'O' Notation:
  O(n) --> Linear
  O(1) --> Constant
  O(n^2) --> Quadratic


Identifying Runtime Complexity

1. Probably O(n) : Iterating with a simple for loop through a single collection?

2. Still O(n). There are no constants in runtime: Iterating through half a collection

3. O(n + m): Iterating through two different collections with separate for loops

4. O(n^2) : Two nested for loops iterating over the same collection

5. O(n*m) : Two nested for loops iterating over different collections

6. O(n*log(n)): Sorting

7. O(log(n)): Searching a sorted Array.





SPACE COMPLEXITY: How much more memory is required by doubling the problem set?


==================== Fibonacci Algorithm using Recursion ============================
function fib(n) {
    if (n < 2) return n;
    
    return fib(n - 1) + fib(n - 2);
}

THAT'S IT !!!!!!!!!!!!!!!!!

MEMOIZATION: Store the arguments of each function call along with the result. If the funtion is called again 
             with the same arguments, return the precomputed result, rather than running the function again.


function memoize(fn) {
    const cache = {};

    return function(...args) {
        if (cache[args]) {
            return cache[args];
        }

        const result = fn.apply(this, args);
        cache[args] = result;

        return result;
    };
}

function slowFib(n) {
    if (n < 2) return n;
    
    return fib(n - 1) + fib(n - 2);
}

fib = memoize(slowFib);

==================== Data Structures ============================

Data Structure: Ways of organizing information with optimal runtime complexity for adding or removing records

Javascript natively implements several data structures. You will still be asked about inferior data structures

==================== The Queue Data Structure ============================
FIFO in Queues (First In First Out)
      Queue                  Array Equivalent
Add to the queue                array.unshift();
Remove from the queue           array.pop();


-----------------------------------------------------------------
    To...                         Run this
Create a new empty queue      const q = new Queue();

Add a record to a queue           q.add(1);

Remove record at the end          q.remove(); 
of a queue


==================== Underwater Queue Weaving ============================




==================== Stack Em Up With Stacs ==============================
FILO (First In Last Out)

Push: Add a record to the stack
Pop: Remove the "top" record in the stack
Peek: Return the "top" record without popping it


==================== Two Become One ==============================

Queue from Stack


==================== Linked List =================================

Node Implementation----------------

In the LinkedList, the head is gonna have reference to the first node of the LinkedList  

==================== Find the Midpoint =================================

function midpoint(list) {
    let slow = list.getFirst(); // list.head;
    let fast = list.getFirst();

    while (fast.next && fast.next.next) {
        slow = slow.next;
        fast = fast.next.next;
    }

    return slow;
}

==================== Circular List =================================

function circular(list) {
    let slow = list.getFirst();// list.head
    let fast = list.getFirst();

    while (fast.next && fast.next.next) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow === fast) {
            return true;
        }
    }

    return false;
}

==================== From Last Question =================================

function fromLast(list, n) {
    let slow = list.getFirst();
    let fast = list.getFirst();

    while (n > 0) {
        fast = fast.next;
        n--;
    }

    while (fast.next) {
        fast = fast.next;
        slow = slow.next;
    }

    return slow;
}

==================== Trees Overview =================================

                20

        0       40      -15

    12  -2  1           -2


Ways of interating into a tree
+ Breadth-First-Traversal: The tree is gonna be iterated from left to right per each level without mattering if the
                           elements are not siblings
    Ex. 20, 0, 40, -15, 12, -2, 1, -2


    traverseBF(fn) {
        const arr = [this.root]; //This will give us the root element of our Tree

        while(arr.length) {
            const node = arr.shift(); //This shift method takes out the first position of the array
            
            arr.push(...node.children); //We want to add all the children from the node
            
            fn(node);
        }
    }


+ Depth-First-Traversal: 20, 0, 12, -2, 1, 40, -15, 2

traverseDF(fn) {
        const arr = [this.root];

        while(arr.length) {
            const node = arr.shift();

            arr.unshift(...node.children);

            fn(node);
        }
}

==================== Trees with Level Width =================================
width === 'Implement Breadth First Traversal'

function levelWidth(root) {
    const arr = [root, 's']; // 's' is the flag to know if we are located at the final of a tree level or not 
    const counters = [0];

    //if arr.length is more than 1 it means there is more values apart from the stopper flag 's'
    while (arr.length > 1) {    
        const node = arr.shift();//Takes out the first element of the array

        if (node === 's') {
            counters.push(0);
            arr.push('s'); //To add again the 's' flag for the next tree level
        } else {
            arr.push(...node.children);
            counters[counters.length - 1]++;
        }
    }

    return counters;
}


==================== My Best Friend Binary Search Tree =================================

+ Every node will have at least two children
+ The left node is always gonna be less than the parent one  (value > left.value)
+ The right node is always gonna be more than the parent one (value < right.value)

Binary Tree dont fill the requirement of the right and left nodes as Binary Search Tree.
The only requirement is to have at least to nodes per parent as mentioned above.


class Node {
    constructor(data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }

    insert(data) {
        if (data < this.data && this.left) {
            this.left.insert(data);
        } else if (data < this.data) {
            this.left = new Node(data);
        } else if (data > this.data && this.right) {
            this.right.insert(data);
        } else if (data > this.data) {
            this.right = new Node(data);
        }
    }

    contains(data) {
        if (this.data === data) {
            return this;
        }

        if (this.data < data && this.right) {
            return this.right.contains(data);
        } else if (this.data > data && this.left) {
            return this.left.contains(data); 
        } 

        return null;
    }


}


==================== Validating a Binary Search Tree =================================

function validate(node, min = null, max = null) {
    if (max !== null && node.data > max) {
        return false;
    }

    if (min !== null && node.data < min) {
        return false;
    }

    if (node.left && !validate(node.left, min, node.data)) {
        return false;
    }

    if (node.right && !validate(node.right, node.data, max)) {
        return false;
    }

    return true;
}

==================== Back to JavaScript Events =================================

class Events {
  constructor() {
    this.events = {};
  }
  // Register an event handler
  on(eventName, callback) {
    if (this.events[eventName]) {
      this.events[eventName].push(callback);
    } else {
      this.events[eventName] = [callback];
    }
  }

  // Trigger all callbacks associated
  // with a given eventName
  trigger(eventName) {
    if (this.events[eventName]) {
      for (let cb of this.events[eventName]) {
        cb();
      }
    }
  }

  // Remove all event handlers associated
  // with the given eventName
  off(eventName) {
    delete this.events[eventName];
  }
}

==================== Sorting with BubbleSort =================================

    Name                Worst Case Runtime                  Difficulty

BubbleSort                      n^2                           easiest

SelectionSort                   n^2                           easier

MergeSort                       n*log(n)                      medium


==================== Angular Unit Testing with Components =================================
Test Driven Development (TDD)

Jasmine Supports Behavior Driven Development (BDD)

with Plunker:

describe('Hello World', () => {

    //Before Each of the tests are gonna be executed
    beforeEach(() => {
        expected = "Hello World";
    }); 

    afterEach(() => {
        expected = "";
    });

    it('says Hello', () => {
        expect(helloWorld())
            .toEqual(expected);
    });
})

beforeAll
afterAll
beforeEach
afterEach



+++++++++++++++++++++++++++++++> EP 13.3 - Angular / Unit Testing / Classes & Pipes <++++++++++++++++++++++++++++++++++++++++

+++++++++> This is the angular service class
export class AuthService {
    isAuthenticated(): boolean {
        return !!localStorage.getItem('token');
    }
}

+++++++++> This is the authService test component
import {AuthService} from './auth.service';

describe('Service Auth', () => {
    let service: AuthService;

    beforeEach(() => {
        service = new AuthService();
    });

    afterEach(() => {
        service =  null;
        localStorage.removeItem('token');
    });

    it('should return true from isAuthenticated when there is a token', () => {
        localStorage.setItem('token', '1234');
        expect(service.isAuthenticated()).toBeTruthy();
    });

    it('should return false from isAuthenticated when there is no token', () => {
        expect(service.isAuthenticated()).toBeFalsy();
    });
})



+++++++++> This is the angular pipe class

import {Pipe, PipeTransform} from '@angular/core';

@Pipe({
    name: 'default'
})

export class DefaultPipe implements PipeTransform {

    transform(value: string, fallback: string, forceHttps: boolean) {
        let image = "";
        if (value) {
            image = value;
        } else {
            image = fallback;
        }
        if (forceHttps) {
            if (image.indexOf("https") == -1) {
                image = image.replace("http", "https");
            }
        }
        return image;
    }

}

+++++++++> This is the angular test pipe component
import {DefaultPipe} from './default.pipe';

descripe('Pipe: Default', () => {
    let pipe : DefaultPipe;

    beforeEach(() => {
        pipe = new DefaultPipe();
    });

    if('providing no value returns fallback', () => {
        expect(pipe.transform('', 'http://place-hold.it/300'))
            .toBe('http://place-hold.it/300')
    });
});

We can test any isolated class with simple jasmine spec file.


+++++++++++++++++++++++++++++++> EP 13.4 - Angular / Unit Testing / Mocks & Spies <++++++++++++++++++++++++++++++++++++++++

+++++++++> This is the angular login component

import {Component} from '@angular/core';
import {AuthService} from './auth.service';

@Component({
    selector: 'app-login',
    template: `<a [hidden]="needsLogin()"> Login </a>`
})

export class LoginComponent {
    constructor(private auth: AuthService) {
    }

    needsLogin() {
        return !this.auth.isAuthenticated;
    }
}

+++++++++> This is the angular service class
export class AuthService {
    isAuthenticated(): boolean {
        return !!localStorage.getItem('token');
    }
}

+++++++++> This is the angular login test component

import {LoginComponent} from './login.component';
import {AuthService} from './auth.service';


describe('Component: LOgin', () => {
    let component: LoginComponent;
    let service: AuthService;

    beforeEach(() => {
        service = new AuthService();
        component = new LoginComponent(service);
    });

    afterEach(() => {
        service = null;
        component = null;
    });

    it('needsLogin returns false when the user is not authenticated', () => {
        spyOn(service, 'isAuthenticated').and.returnValue(false);
        expect(component.needsLogin()).toBeTruthy();
        expect(service.isAuthenticated).toHaveBeenCalled();
    });

    it('needsLogin returns false when the user is not authenticated', () => {
        spyOn(service, 'isAuthenticated').and.returnValue(true);
        expect(component.needsLogin()).toBeFalsy();
        expect(service.isAuthenticated).toHaveBeenCalled();
    });
});


+++++++++++++++++++++++++++++++> EP 13.5 - Angular / Unit Testing / Angular Test Bed <++++++++++++++++++++++++++++++++++++++++

+ What is Angular Test Bed (ATB) and how to use it.
+ When to use ATB vs. plain vanilla Jasmine tests.


+++++++++> This is the angular login test bed component

import {TestBed, ComponentFixture} from '@angular/core/testing';
import {LoginComponent} from './login.component';
import {AuthService} from './auth.service';

describe('Component: Login', () => {

    let component: LoginComponent
    let fixture: ComponentFixture<LoginComponent>;
    let authService: AuthService;

    beforeEach(() => {
        TestBed.configureTestingModule({
            declarations: [LoginComponent],
            providers: [AuthService]
        });   
    })

    fixture = TestBed.createComponent(LoginComponent);

    component = fixture.componentInstance;

    authService = TestBed.get(AuthService);

    it('needsLogin returns false when the user is not authenticated', () => {
        spyOn(service, 'isAuthenticated').and.returnValue(false);
        expect(component.needsLogin()).toBeTruthy();
        expect(service.isAuthenticated).toHaveBeenCalled();
    });

    it('needsLogin returns false when the user is not authenticated', () => {
        spyOn(service, 'isAuthenticated').and.returnValue(true);
        expect(component.needsLogin()).toBeFalsy();
        expect(service.isAuthenticated).toHaveBeenCalled();
    });

});

++++++++++++++++++++++++ When to use ATB ++++++++++++++++++++++++++
+ Test the interaction of a directive or component with it's template.
+ Test change detection.
+ Test and use Angular DI(Dependency Injection) framework
+ Test the NgModule configuration we use in our application
+ The ATB lets us test parts of our Angular application as it will beinf run in the context of a real running Angular application

+++++++++++++++++++++++++++++++> EP 13.6 - Angular / Unit Testing / Change Detection <++++++++++++++++++++++++++++++++++++++++  


+++++++++> This is the angular login component

import {Component} from '@angular/core';
import {AuthService} from './auth.service';

@Component({
    selector: 'app-login',
    template: `
    <a>
      <span *ngIf="needsLogin()">Login</span>
      <span *ngIf="!needsLogin()">Logout</span> 
    </a>`
})

export class LoginComponent {
    constructor(private auth: AuthService) {
    }

    needsLogin() {
        return !this.auth.isAuthenticated;
    }
}


+++++++++> This is the angular login test bed component

import {TestBed, ComponentFixture} from '@angular/core/testing';
import {LoginComponent} from './login.component';
import {AuthService} from './auth.service';
import {DebugElement} from '@angular/core';
import {By} from '@angular/platform-browser';

describe('Component: Login', () => {

    let component: LoginComponent
    let fixture: ComponentFixture<LoginComponent>;
    let authService: AuthService;
    let el: DebugElement;

    beforeEach(() => {
        TestBed.configureTestingModule({
            declarations: [LoginComponent],
            providers: [AuthService]
        });   
    })

    fixture = TestBed.createComponent(LoginComponent);

    component = fixture.componentInstance;

    authService = TestBed.get(AuthService);

    el = fixture.debugElement.query(By.css('a'));

    it('login button hidden when the user is authenticated', () => {
        expect(el.nativeElement.textContent.trim()).toBe('');
        fixture.detectChanges();
        expect(el.nativeElement.textContent.trim()).toBe('Login');
        spyOn(authService 'isAuthenticated').and.returnValue(true);
        expect(el.nativeElement.textContent.trim()).toBe('Login');
        fixture.detectChanges();
        expect(el.nativeElement.textContent.trim()).toBe('Logout');
    });

});


+ By using the ATB and fixtures we can inspect the components view through fixture.debugElement and 
  also trigger a change detection run by calling fixture.detectChanges();


+++++++++++++++++++++++++++++++> EP 13.7 - Angular / Unit Testing / Asynchronous Code <++++++++++++++++++++++++++++++++++++++++ 

+++++++++> This is the angular service class
export class AuthService {
    isAuthenticated(): Promise<boolean> {
        return Promise.resolve(!!localStorage.getItem('token'));
    }
}

+++++++++> This is the angular login component

import {Component} from '@angular/core';
import {AuthService} from './auth.service';

@Component({
    selector: 'app-login',
    template: `
    <a>
      <span *ngIf="needsLogin()">Login</span>
      <span *ngIf="!needsLogin()">Logout</span> 
    </a>`
})

export class LoginComponent implements OnInit {

    needsLogin: boolean = true;

    constructor(private auth: AuthService) {
    }

    ngOnInit() {
        this.auth.isAuthenticated().then((authenticated) => {
            this.needsLogin = !authenticated;
        })
    }

    needsLogin() {
        return !this.auth.isAuthenticated;
    }
}


+++++++++> This is the angular login test bed component

import {TestBed, ComponentFixture, async, whenStatble, fakeAsync, tick} from '@angular/core/testing';
import {LoginComponent} from './login.component';
import {AuthService} from './auth.service';
import {DebugElement} from '@angular/core';
import {By} from '@angular/platform-browser';

describe('Component: Login', () => {

    let component: LoginComponent
    let fixture: ComponentFixture<LoginComponent>;
    let authService: AuthService;
    let el: DebugElement;

    beforeEach(() => {
        TestBed.configureTestingModule({
            declarations: [LoginComponent],
            providers: [AuthService]
        });   
    })

    fixture = TestBed.createComponent(LoginComponent);

    component = fixture.componentInstance;

    authService = TestBed.get(AuthService);

    el = fixture.debugElement.query(By.css('a'));

    /*
        it('Button label', (done) => {
            fixture.detectChanges();
            expect(el.nativeElement.textContent.trim()).toBe('Login');
            let spy = spyOn(authService 'isAuthenticated').and.returnValue(Promise.resolve(true));
            component.ngOnInit();

            spy.calls.mostRecent().returnValue.then(() => {
                fixture.detectChanges();
                expect(el.nativeElement.textContent.trim()).toBe('Logout');
                done();
            });
        }); 
    */

    /*
        it('Button label', async(() => {
            fixture.detectChanges();
            expect(el.nativeElement.textContent.trim()).toBe('Login');
            let spy = spyOn(authService 'isAuthenticated').and.returnValue(Promise.resolve(true));
            component.ngOnInit();

            spy.whenStatble().then(() => {
                fixture.detectChanges();
                expect(el.nativeElement.textContent.trim()).toBe('Logout');
            });
        })); 
    */

        it('Button label', fakeAsync(() => {
            fixture.detectChanges();
            expect(el.nativeElement.textContent.trim()).toBe('Login');
            let spy = spyOn(authService 'isAuthenticated').and.returnValue(Promise.resolve(true));
            component.ngOnInit();

            tick(); // blocks execution simulates the passage of time until all pending asynchronous activities get completed
            //Blocks and wait for all the promises to be result

            
            fixture.detectChanges();
            expect(el.nativeElement.textContent.trim()).toBe('Logout');
            
        })); 

});



+++++++++++++++++++++++++++++++> EP 13.8 - Angular / Unit Testing / Dependency Injection <++++++++++++++++++++++++++++++++++++++++ 

+++++++++> This is the angular login test bed component

import {TestBed, ComponentFixture inject} from '@angular/core/testing';
import {LoginComponent} from './login.component';
import {AuthService} from './auth.service';

class MockAuthService extends AuthService {
    isAuthenticated() {
        return 'Mocked';
    }
}

describe('Component: Login', () => {

    let component: LoginComponent
    let fixture: ComponentFixture<LoginComponent>;
    let authService: AuthService;
    let componentService: AuthService;

    beforeEach(() => {
        TestBed.configureTestingModule({
            declarations: [LoginComponent],
            providers: [AuthService]
        });   

        TestBed.overrideComponent(
            LoginComponent,
            {set: {providers: [{provide: AuthService, useClass: MockAuthService}]}}
        );
    
        fixture = TestBed.createComponent(LoginComponent);
        component = fixture.componentInstance;

        testBedService = TestBed.get(AuthService);
        componentService = fixture.debugElement.injector.get(AuthService);

    })

    it('Service injected via inject(...) and TestBed.get(...) should be the same instance', 
        inject([AuthService], (injectService: AuthService) => {
            expect(injectService)toBe(testBedService);
        });
    );

    it('Service injected via component should be and instance of MockAuthService', () => {
       expect(componentService instanceof MockAuthService).toBeTruthy(); 
    });
});


+++++++++++++++++++++++++++++++> EP 13.9 - Angular / Unit Testing / Components <++++++++++++++++++++++++++++++++++++++++

+++++++++> This is the angular login component
import {Component, EventEmitter, Input, Output} from '@angular/core';

export class User {
    constructor(public email: string, public password: string) {

    }
}

@Component({
    selector: 'app-login',
    template: `

<form>
    <label>Email</label>
    <input type="email" #email/>
    <label>Password</label>
    <input type="password" #password/>
    <button type="button"
            (click)="login(email.value, password.value)"
            [disabled]="!enabled">Login
    </button>
</form>
    
    `
})

export class LoginComponent {
    @Output() LoggedIn = EventEmitter<User>();
    @Input() enabled = true;

    login(email, password) {
        console.log(`Login ${email} ${password}`);
        if (email %% password) {
            console.log('Emitting');
            this.LoggedIn.emit(new User(email, password));
        }
    }
}


+++++++++> This is the angular login test bed component

import {TestBed, ComponentFixture} from '@angular/core/testing';
import {LoginComponent, User} from './login.component';
import {Component, DebugElement} from '@angular/core';
import {By} from '@angular/platform-browser';


describe('Component: Login', () => {

    let component: LoginComponent
    let fixture: ComponentFixture<LoginComponent>;
    let submitEl: DebugElement;
    let loginEl: DebugElement;
    let passwordEl: DebugElement;

    beforeEach(() => {
        TestBed.configureTestingModule({
            declarations: [LoginComponent]
        });   
    
        fixture = TestBed.createComponent(LoginComponent);
        component = fixture.componentInstance;

        submitEl = fixture.debugElement.query(By.css('button'));
        loginEl = fixture.debugElement.query(By.css('input[type=email]'));
        passwordEl = fixture.debugElement.query(By.css('input[type=password]'));
    })

    it('Setting enabled to false the submit button', () => {
       component.enabled = false;
       fixture.detectChanges();
       expect(submitEl.nativeElement.disabled).toBeTruthy();
    });

    it('Entering email and password emits loggedIn event', () => {
        let user: User;
        loginEl.nativeElement.value = "test@example.com"
        passwordEl.nativeElement.value= "123456";

        component.loggedIn.subscribe((value) => user = value);

        submitEl.triggerEventHandler('click', null);

        expect(user.email).toBe('test@example.com');
        expect(user.password).toBe("123456");
    });
});


+++++++++++++++++++++++++++++++> EP 13.10 - Angular / Unit Testing / Directives <++++++++++++++++++++++++++++++++++++++++

+++++++++> This is the directive component

import {
    Directive,
    HostListener,
    HostBinding
} from '@angular/core';

@Directive({
    selector: '[hoverFocus]'
})

export class HoverFocusDirective {

    @HostBinding("style.background-color") backgroundColor: string;

    @HostListener('mouseover') onHover() {
        this.background = 'blue';
    }

    @HostListener('mouseut') onLeave() {
        this.backgroundColor = 'inherit';
    }
}

+++++++++> This is the directive Testbed component

import {TestBed, ComponentFixture} from '@angular/core/testing';
import {Component, DebugElement} from '@angular/core';
import {By} from '@angular/platform-browser';
import {HoverFocusDirective} from './hoverfocus.directive';

@Component({
    template: `<input type="text" hoverfocus />`
})
class TestHoverFocusComponent {

}

describe('Directive: Hoverfocus', () => {
    let component: TestHoverFocusComponent;
    let fixture: ComponentFixture<TestHoverFocusComponent>;

    beforeEach(() => {
        TestBed.configureTestingModule({
            declarations: [HoverFocusDirective, TestHoverFocusComponent]
        });

        fixture = TestBed.createComponent(TestHoverFocusComponent);
        component = fixture.componentInstance;
        inputEl = fixture.debugElement.query(By.css('input'));
    });

    it('hovering over input', () => {
        inputEl.triggerEventHandler('mouseover', null);
        fixture.detectChanges();
        expect(inputEl.nativeElement.style.backgroundColor).toBe('blue');

        inputEl.triggerEventHandler('mouseout', null);
        fixture.detectChanges();
        expect(inputEl-nativeElement.style.background).toBe('inherit');
    });
});

+++++++++++++++++++++++++++++++> EP 13.11 - Angular / Unit Testing / Model Driven Forms <++++++++++++++++++++++++++++++++++++++++
