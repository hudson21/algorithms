==================== Evaluating Coding Ability ============================
1. Take-home assignment
2. Pair programming at a computer
3. Whiteboarding

npm install -g jest

jest fib/test.js --watch

==================== Reverse String ============================
node inspect index.js

==================== Palindrome ============================
Array Helper: Array.prototype.every();

function isBelowThreshold(currentValue) {
  return currentValue < 40;
}

var array1 = [1, 30, 39, 29, 10, 13];

console.log(array1.every(isBelowThreshold));
// expected output: true

==================== Integer Reversal ============================
Math.sign()

Math.sign(3);     //  1
Math.sign(-3);    // -1
Math.sign('-3');  // -1
Math.sign(0);     //  0
Math.sign(-0);    // -0
Math.sign(NaN);   // NaN
Math.sign('foo'); // NaN
Math.sign();      // NaN

convert a string to a number parseInt('string number')

==================== Max Chars ============================

for of : It is used FOR iterating  an array or string, or array of objects;
for in: specifically for objects

==================== The classic Fizz Buzz ============================

==================== Array Chunking ============================
slice method 

==================== Anagrams ============================
https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/RegExp
RegExp: Regular Expressions

const word = "HI THERE !!!!!";
word.replace(/[^\w]/g, "") //Replace the spaces no spaces

==================== Sentence Capitalization ============================
https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/String/slice

str.slice(beginIndex[, endIndex])

El siguiente ejemplo usa slice() para crear una nueva cadena.

var cadena1 = "La mañana se nos echa encima.";
var cadena2 = cadena1.slice(3, -2);
console.log(cadena2);
Esto escribe:

mañana se nos echa encim

==================== Printing Steps ============================


==================== Find the vowels ============================
word.includes("o");

function vowels(str) {
   // g: dont stop in the first match
   // i: insensitive cases lowerCase and upperCase
   const matches = str.match(/[aeiou]/gi);
   return matches ? matches.length : 0;
}

==================== Enter the Matrix Spiral ============================

Try to do it by yourself again

==================== Runtime Complexity ============================
Describes the performance of an algorithm
How much more processing power/time is required to run your algorithm if we double the inputs?

LINEAR RUNTIME: There is a direct one to one relationship between the number of input elements and the amount of work that 
it needs to be processed 

An example of linear runtime could be the Reverse algorithm

N TIMES COMPLEXITY OR CUADRATIC COMPLEXITY: The Steps algorithm is an example of this type of runtime 


Runtime Types:


Constant Time  1 : No matter how many elements we are working with, the algorithm/operation/whatever will always
                   take the same amount of time;

Logaritmic Time log(n) : You have this is doubling the number of elements you are iterating over does not double the amount
                         of work . Always assume that searching operations are log(n)

Linear Time n : Iterating throughall elements in a collection of data.  If you see a for loop spanning from '0' to 'array.length',
                you probably have 'n', or linear runtime.

Quasilinear Time n * log(n) : You have this if doubling the number of elements you are iterating over does not double the amount 
                              of work. Always assume that any sorting operation is n*log(n)

Quadratic Time n ^ 2 : Every element in a collection has to be compared to every other element. 'The handshake problem'

Exponential Time 2 ^ n : If you add a "single" element to a collection, the processing power required doubles

1. filter
2. sort


-------------------------------------------------
Big 'O' Notation:
  O(n) --> Linear
  O(1) --> Constant
  O(n^2) --> Quadratic


Identifying Runtime Complexity

1. Probably O(n) : Iterating with a simple for loop through a single collection?

2. Still O(n). There are no constants in runtime: Iterating through half a collection

3. O(n + m): Iterating through two different collections with separate for loops

4. O(n^2) : Two nested for loops iterating over the same collection

5. O(n*m) : Two nested for loops iterating over different collections

6. O(n*log(n)): Sorting

7. O(log(n)): Searching a sorted Array.





SPACE COMPLEXITY: How much more memory is required by doubling the problem set?


==================== Fibonacci Algorithm using Recursion ============================
function fib(n) {
    if (n < 2) return n;
    
    return fib(n - 1) + fib(n - 2);
}

THAT'S IT !!!!!!!!!!!!!!!!!

MEMOIZATION: Store the arguments of each function call along with the result. If the funtion is called again 
             with the same arguments, return the precomputed result, rather than running the function again.


function memoize(fn) {
    const cache = {};

    return function(...args) {
        if (cache[args]) {
            return cache[args];
        }

        const result = fn.apply(this, args);
        cache[args] = result;

        return result;
    };
}

function slowFib(n) {
    if (n < 2) return n;
    
    return fib(n - 1) + fib(n - 2);
}

fib = memoize(slowFib);

==================== Data Structures ============================

Data Structure: Ways of organizing information with optimal runtime complexity for adding or removing records

Javascript natively implements several data structures. You will still be asked about inferior data structures

==================== The Queue Data Structure ============================
FIFO in Queues (First In First Out)
      Queue                  Array Equivalent
Add to the queue                array.unshift();
Remove from the queue           array.pop();


-----------------------------------------------------------------
    To...                         Run this
Create a new empty queue      const q = new Queue();

Add a record to a queue           q.add(1);

Remove record at the end          q.remove(); 
of a queue


==================== Underwater Queue Weaving ============================




==================== Stack Em Up With Stacs ==============================
FILO (First In Last Out)

Push: Add a record to the stack
Pop: Remove the "top" record in the stack
Peek: Return the "top" record without popping it


==================== Two Become One ==============================

Queue from Stack


==================== Linked List =================================

Node Implementation----------------

In the LinkedList, the head is gonna have reference to the first node of the LinkedList  

==================== Find the Midpoint =================================

function midpoint(list) {
    let slow = list.getFirst(); // list.head;
    let fast = list.getFirst();

    while (fast.next && fast.next.next) {
        slow = slow.next;
        fast = fast.next.next;
    }

    return slow;
}

==================== Circular List =================================

function circular(list) {
    let slow = list.getFirst();// list.head
    let fast = list.getFirst();

    while (fast.next && fast.next.next) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow === fast) {
            return true;
        }
    }

    return false;
}

==================== From Last Question =================================

function fromLast(list, n) {
    let slow = list.getFirst();
    let fast = list.getFirst();

    while (n > 0) {
        fast = fast.next;
        n--;
    }

    while (fast.next) {
        fast = fast.next;
        slow = slow.next;
    }

    return slow;
}

==================== Trees Overview =================================

                20

        0       40      -15

    12  -2  1           -2


Ways of interating into a tree
+ Breadth-First-Traversal: The tree is gonna be iterated from left to right per each level without mattering if the
                           elements are not siblings
    Ex. 20, 0, 40, -15, 12, -2, 1, -2


    traverseBF(fn) {
        const arr = [this.root]; //This will give us the root element of our Tree

        while(arr.length) {
            const node = arr.shift(); //This shift method takes out the first position of the array
            
            arr.push(...node.children); //We want to add all the children from the node
            
            fn(node);
        }
    }


+ Depth-First-Traversal: 20, 0, 12, -2, 1, 40, -15, 2

traverseDF(fn) {
        const arr = [this.root];

        while(arr.length) {
            const node = arr.shift();

            arr.unshift(...node.children);

            fn(node);
        }
}

==================== Trees with Level Width =================================
width === 'Implement Breadth First Traversal'

function levelWidth(root) {
    const arr = [root, 's']; // 's' is the flag to know if we are located at the final of a tree level or not 
    const counters = [0];

    //if arr.length is more than 1 it means there is more values apart from the stopper flag 's'
    while (arr.length > 1) {    
        const node = arr.shift();//Takes out the first element of the array

        if (node === 's') {
            counters.push(0);
            arr.push('s'); //To add again the 's' flag for the next tree level
        } else {
            arr.push(...node.children);
            counters[counters.length - 1]++;
        }
    }

    return counters;
}


==================== My Best Friend Binary Search Tree =================================

+ Every node will have at least two children
+ The left node is always gonna be less than the parent one  (value > left.value)
+ The right node is always gonna be more than the parent one (value < right.value)

Binary Tree dont fill the requirement of the right and left nodes as Binary Search Tree.
The only requirement is to have at least to nodes per parent as mentioned above.


class Node {
    constructor(data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }

    insert(data) {
        if (data < this.data && this.left) {
            this.left.insert(data);
        } else if (data < this.data) {
            this.left = new Node(data);
        } else if (data > this.data && this.right) {
            this.right.insert(data);
        } else if (data > this.data) {
            this.right = new Node(data);
        }
    }

    contains(data) {
        if (this.data === data) {
            return this;
        }

        if (this.data < data && this.right) {
            return this.right.contains(data);
        } else if (this.data > data && this.left) {
            return this.left.contains(data); 
        } 

        return null;
    }


}


==================== Validating a Binary Search Tree =================================

function validate(node, min = null, max = null) {
    if (max !== null && node.data > max) {
        return false;
    }

    if (min !== null && node.data < min) {
        return false;
    }

    if (node.left && !validate(node.left, min, node.data)) {
        return false;
    }

    if (node.right && !validate(node.right, node.data, max)) {
        return false;
    }

    return true;
}

==================== Back to JavaScript Events =================================

class Events {
  constructor() {
    this.events = {};
  }
  // Register an event handler
  on(eventName, callback) {
    if (this.events[eventName]) {
      this.events[eventName].push(callback);
    } else {
      this.events[eventName] = [callback];
    }
  }

  // Trigger all callbacks associated
  // with a given eventName
  trigger(eventName) {
    if (this.events[eventName]) {
      for (let cb of this.events[eventName]) {
        cb();
      }
    }
  }

  // Remove all event handlers associated
  // with the given eventName
  off(eventName) {
    delete this.events[eventName];
  }
}

==================== Sorting with BubbleSort =================================

    Name                Worst Case Runtime                  Difficulty

BubbleSort                      n^2                           easiest

SelectionSort                   n^2                           easier

MergeSort                       n*log(n)                      medium


==================== Angular Unit Testing with Components =================================
Test Driven Development (TDD)

Jasmine Supports Behavior Driven Development (BDD)

with Plunker:

describe('Hello World', () => {

    //Before Each of the tests are gonna be executed
    beforeEach(() => {
        expected = "Hello World";
    }); 

    afterEach(() => {
        expected = "";
    });

    it('says Hello', () => {
        expect(helloWorld())
            .toEqual(expected);
    });
})

beforeAll
afterAll
beforeEach
afterEach



+++++++++++++++++++++++++++++++> EP 13.3 - Angular / Unit Testing / Classes & Pipes <++++++++++++++++++++++++++++++++++++++++

+++++++++> This is the angular service class
export class AuthService {
    isAuthenticated(): boolean {
        return !!localStorage.getItem('token');
    }
}

+++++++++> This is the authService test component
import {AuthService} from './auth.service';

describe('Service Auth', () => {
    let service: AuthService;

    beforeEach(() => {
        service = new AuthService();
    });

    afterEach(() => {
        service =  null;
        localStorage.removeItem('token');
    });

    it('should return true from isAuthenticated when there is a token', () => {
        localStorage.setItem('token', '1234');
        expect(service.isAuthenticated()).toBeTruthy();
    });

    it('should return false from isAuthenticated when there is no token', () => {
        expect(service.isAuthenticated()).toBeFalsy();
    });
})



+++++++++> This is the angular pipe class

import {Pipe, PipeTransform} from '@angular/core';

@Pipe({
    name: 'default'
})

export class DefaultPipe implements PipeTransform {

    transform(value: string, fallback: string, forceHttps: boolean) {
        let image = "";
        if (value) {
            image = value;
        } else {
            image = fallback;
        }
        if (forceHttps) {
            if (image.indexOf("https") == -1) {
                image = image.replace("http", "https");
            }
        }
        return image;
    }

}

+++++++++> This is the angular test pipe component
import {DefaultPipe} from './default.pipe';

descripe('Pipe: Default', () => {
    let pipe : DefaultPipe;

    beforeEach(() => {
        pipe = new DefaultPipe();
    });

    if('providing no value returns fallback', () => {
        expect(pipe.transform('', 'http://place-hold.it/300'))
            .toBe('http://place-hold.it/300')
    });
});

We can test any isolated class with simple jasmine spec file.


+++++++++++++++++++++++++++++++> EP 13.4 - Angular / Unit Testing / Mocks & Spies <++++++++++++++++++++++++++++++++++++++++

+++++++++> This is the angular login component

import {Component} from '@angular/core';
import {AuthService} from './auth.service';

@Component({
    selector: 'app-login',
    template: `<a [hidden]="needsLogin()"> Login </a>`
})

export class LoginComponent {
    constructor(private auth: AuthService) {
    }

    needsLogin() {
        return !this.auth.isAuthenticated;
    }
}

+++++++++> This is the angular service class
export class AuthService {
    isAuthenticated(): boolean {
        return !!localStorage.getItem('token');
    }
}

+++++++++> This is the angular login test component

import {LoginComponent} from './login.component';
import {AuthService} from './auth.service';


describe('Component: LOgin', () => {
    let component: LoginComponent;
    let service: AuthService;

    beforeEach(() => {
        service = new AuthService();
        component = new LoginComponent(service);
    });

    afterEach(() => {
        service = null;
        component = null;
    });

    it('needsLogin returns false when the user is not authenticated', () => {
        spyOn(service, 'isAuthenticated').and.returnValue(false);
        expect(component.needsLogin()).toBeTruthy();
        expect(service.isAuthenticated).toHaveBeenCalled();
    });

    it('needsLogin returns false when the user is not authenticated', () => {
        spyOn(service, 'isAuthenticated').and.returnValue(true);
        expect(component.needsLogin()).toBeFalsy();
        expect(service.isAuthenticated).toHaveBeenCalled();
    });
});


+++++++++++++++++++++++++++++++> EP 13.5 - Angular / Unit Testing / Angular Test Bed <++++++++++++++++++++++++++++++++++++++++

+ What is Angular Test Bed (ATB) and how to use it.
+ When to use ATB vs. plain vanilla Jasmine tests.


+++++++++> This is the angular login test bed component

import {TestBed, ComponentFixture} from '@angular/core/testing';
import {LoginComponent} from './login.component';
import {AuthService} from './auth.service';

describe('Component: Login', () => {

    let component: LoginComponent
    let fixture: ComponentFixture<LoginComponent>;
    let authService: AuthService;

    beforeEach(() => {
        TestBed.configureTestingModule({
            declarations: [LoginComponent],
            providers: [AuthService]
        });   
    })

    fixture = TestBed.createComponent(LoginComponent);

    component = fixture.componentInstance;

    authService = TestBed.get(AuthService);

    it('needsLogin returns false when the user is not authenticated', () => {
        spyOn(service, 'isAuthenticated').and.returnValue(false);
        expect(component.needsLogin()).toBeTruthy();
        expect(service.isAuthenticated).toHaveBeenCalled();
    });

    it('needsLogin returns false when the user is not authenticated', () => {
        spyOn(service, 'isAuthenticated').and.returnValue(true);
        expect(component.needsLogin()).toBeFalsy();
        expect(service.isAuthenticated).toHaveBeenCalled();
    });

});

++++++++++++++++++++++++ When to use ATB ++++++++++++++++++++++++++
+ Test the interaction of a directive or component with it's template.
+ Test change detection.
+ Test and use Angular DI(Dependency Injection) framework
+ Test the NgModule configuration we use in our application
+ The ATB lets us test parts of our Angular application as it will beinf run in the context of a real running Angular application

+++++++++++++++++++++++++++++++> EP 13.6 - Angular / Unit Testing / Change Detection <++++++++++++++++++++++++++++++++++++++++  


+++++++++> This is the angular login component

import {Component} from '@angular/core';
import {AuthService} from './auth.service';

@Component({
    selector: 'app-login',
    template: `
    <a>
      <span *ngIf="needsLogin()">Login</span>
      <span *ngIf="!needsLogin()">Logout</span> 
    </a>`
})

export class LoginComponent {
    constructor(private auth: AuthService) {
    }

    needsLogin() {
        return !this.auth.isAuthenticated;
    }
}


+++++++++> This is the angular login test bed component

import {TestBed, ComponentFixture} from '@angular/core/testing';
import {LoginComponent} from './login.component';
import {AuthService} from './auth.service';
import {DebugElement} from '@angular/core';
import {By} from '@angular/platform-browser';

describe('Component: Login', () => {

    let component: LoginComponent
    let fixture: ComponentFixture<LoginComponent>;
    let authService: AuthService;
    let el: DebugElement;

    beforeEach(() => {
        TestBed.configureTestingModule({
            declarations: [LoginComponent],
            providers: [AuthService]
        });   
    })

    fixture = TestBed.createComponent(LoginComponent);

    component = fixture.componentInstance;

    authService = TestBed.get(AuthService);

    el = fixture.debugElement.query(By.css('a'));

    it('login button hidden when the user is authenticated', () => {
        expect(el.nativeElement.textContent.trim()).toBe('');
        fixture.detectChanges();
        expect(el.nativeElement.textContent.trim()).toBe('Login');
        spyOn(authService 'isAuthenticated').and.returnValue(true);
        expect(el.nativeElement.textContent.trim()).toBe('Login');
        fixture.detectChanges();
        expect(el.nativeElement.textContent.trim()).toBe('Logout');
    });

});


+ By using the ATB and fixtures we can inspect the components view through fixture.debugElement and 
  also trigger a change detection run by calling fixture.detectChanges();


+++++++++++++++++++++++++++++++> EP 13.7 - Angular / Unit Testing / Asynchronous Code <++++++++++++++++++++++++++++++++++++++++ 

+++++++++> This is the angular service class
export class AuthService {
    isAuthenticated(): Promise<boolean> {
        return Promise.resolve(!!localStorage.getItem('token'));
    }
}

+++++++++> This is the angular login component

import {Component} from '@angular/core';
import {AuthService} from './auth.service';

@Component({
    selector: 'app-login',
    template: `
    <a>
      <span *ngIf="needsLogin()">Login</span>
      <span *ngIf="!needsLogin()">Logout</span> 
    </a>`
})

export class LoginComponent implements OnInit {

    needsLogin: boolean = true;

    constructor(private auth: AuthService) {
    }

    ngOnInit() {
        this.auth.isAuthenticated().then((authenticated) => {
            this.needsLogin = !authenticated;
        })
    }

    needsLogin() {
        return !this.auth.isAuthenticated;
    }
}


+++++++++> This is the angular login test bed component

import {TestBed, ComponentFixture, async, whenStatble, fakeAsync, tick} from '@angular/core/testing';
import {LoginComponent} from './login.component';
import {AuthService} from './auth.service';
import {DebugElement} from '@angular/core';
import {By} from '@angular/platform-browser';

describe('Component: Login', () => {

    let component: LoginComponent
    let fixture: ComponentFixture<LoginComponent>;
    let authService: AuthService;
    let el: DebugElement;

    beforeEach(() => {
        TestBed.configureTestingModule({
            declarations: [LoginComponent],
            providers: [AuthService]
        });   
    })

    fixture = TestBed.createComponent(LoginComponent);

    component = fixture.componentInstance;

    authService = TestBed.get(AuthService);

    el = fixture.debugElement.query(By.css('a'));

    /*
        it('Button label', (done) => {
            fixture.detectChanges();
            expect(el.nativeElement.textContent.trim()).toBe('Login');
            let spy = spyOn(authService 'isAuthenticated').and.returnValue(Promise.resolve(true));
            component.ngOnInit();

            spy.calls.mostRecent().returnValue.then(() => {
                fixture.detectChanges();
                expect(el.nativeElement.textContent.trim()).toBe('Logout');
                done();
            });
        }); 
    */

    /*
        it('Button label', async(() => {
            fixture.detectChanges();
            expect(el.nativeElement.textContent.trim()).toBe('Login');
            let spy = spyOn(authService 'isAuthenticated').and.returnValue(Promise.resolve(true));
            component.ngOnInit();

            spy.whenStatble().then(() => {
                fixture.detectChanges();
                expect(el.nativeElement.textContent.trim()).toBe('Logout');
            });
        })); 
    */

        it('Button label', fakeAsync(() => {
            fixture.detectChanges();
            expect(el.nativeElement.textContent.trim()).toBe('Login');
            let spy = spyOn(authService 'isAuthenticated').and.returnValue(Promise.resolve(true));
            component.ngOnInit();

            tick(); // blocks execution simulates the passage of time until all pending asynchronous activities get completed
            //Blocks and wait for all the promises to be result

            
            fixture.detectChanges();
            expect(el.nativeElement.textContent.trim()).toBe('Logout');
            
        })); 

});



+++++++++++++++++++++++++++++++> EP 13.8 - Angular / Unit Testing / Dependency Injection <++++++++++++++++++++++++++++++++++++++++ 

+++++++++> This is the angular login test bed component

import {TestBed, ComponentFixture inject} from '@angular/core/testing';
import {LoginComponent} from './login.component';
import {AuthService} from './auth.service';

class MockAuthService extends AuthService {
    isAuthenticated() {
        return 'Mocked';
    }
}

describe('Component: Login', () => {

    let component: LoginComponent
    let fixture: ComponentFixture<LoginComponent>;
    let authService: AuthService;
    let componentService: AuthService;

    beforeEach(() => {
        TestBed.configureTestingModule({
            declarations: [LoginComponent],
            providers: [AuthService]
        });   

        TestBed.overrideComponent(
            LoginComponent,
            {set: {providers: [{provide: AuthService, useClass: MockAuthService}]}}
        );
    
        fixture = TestBed.createComponent(LoginComponent);
        component = fixture.componentInstance;

        testBedService = TestBed.get(AuthService);
        componentService = fixture.debugElement.injector.get(AuthService);

    })

    it('Service injected via inject(...) and TestBed.get(...) should be the same instance', 
        inject([AuthService], (injectService: AuthService) => {
            expect(injectService)toBe(testBedService);
        });
    );

    it('Service injected via component should be and instance of MockAuthService', () => {
       expect(componentService instanceof MockAuthService).toBeTruthy(); 
    });
});


+++++++++++++++++++++++++++++++> EP 13.9 - Angular / Unit Testing / Components <++++++++++++++++++++++++++++++++++++++++

+++++++++> This is the angular login component
import {Component, EventEmitter, Input, Output} from '@angular/core';

export class User {
    constructor(public email: string, public password: string) {

    }
}

@Component({
    selector: 'app-login',
    template: `

<form>
    <label>Email</label>
    <input type="email" #email/>
    <label>Password</label>
    <input type="password" #password/>
    <button type="button"
            (click)="login(email.value, password.value)"
            [disabled]="!enabled">Login
    </button>
</form>
    
    `
})

export class LoginComponent {
    @Output() LoggedIn = EventEmitter<User>();
    @Input() enabled = true;

    login(email, password) {
        console.log(`Login ${email} ${password}`);
        if (email %% password) {
            console.log('Emitting');
            this.LoggedIn.emit(new User(email, password));
        }
    }
}


+++++++++> This is the angular login test bed component

import {TestBed, ComponentFixture} from '@angular/core/testing';
import {LoginComponent, User} from './login.component';
import {Component, DebugElement} from '@angular/core';
import {By} from '@angular/platform-browser';


describe('Component: Login', () => {

    let component: LoginComponent
    let fixture: ComponentFixture<LoginComponent>;
    let submitEl: DebugElement;
    let loginEl: DebugElement;
    let passwordEl: DebugElement;

    beforeEach(() => {
        TestBed.configureTestingModule({
            declarations: [LoginComponent]
        });   
    
        fixture = TestBed.createComponent(LoginComponent);
        component = fixture.componentInstance;

        submitEl = fixture.debugElement.query(By.css('button'));
        loginEl = fixture.debugElement.query(By.css('input[type=email]'));
        passwordEl = fixture.debugElement.query(By.css('input[type=password]'));
    })

    it('Setting enabled to false the submit button', () => {
       component.enabled = false;
       fixture.detectChanges();
       expect(submitEl.nativeElement.disabled).toBeTruthy();
    });

    it('Entering email and password emits loggedIn event', () => {
        let user: User;
        loginEl.nativeElement.value = "test@example.com"
        passwordEl.nativeElement.value= "123456";

        component.loggedIn.subscribe((value) => user = value);

        submitEl.triggerEventHandler('click', null);

        expect(user.email).toBe('test@example.com');
        expect(user.password).toBe("123456");
    });
});


+++++++++++++++++++++++++++++++> EP 13.10 - Angular / Unit Testing / Directives <++++++++++++++++++++++++++++++++++++++++

+++++++++> This is the directive component

import {
    Directive,
    HostListener,
    HostBinding
} from '@angular/core';

@Directive({
    selector: '[hoverFocus]'
})

export class HoverFocusDirective {

    @HostBinding("style.background-color") backgroundColor: string;

    @HostListener('mouseover') onHover() {
        this.background = 'blue';
    }

    @HostListener('mouseut') onLeave() {
        this.backgroundColor = 'inherit';
    }
}

+++++++++> This is the directive Testbed component

import {TestBed, ComponentFixture} from '@angular/core/testing';
import {Component, DebugElement} from '@angular/core';
import {By} from '@angular/platform-browser';
import {HoverFocusDirective} from './hoverfocus.directive';

@Component({
    template: `<input type="text" hoverfocus />`
})
class TestHoverFocusComponent {

}

describe('Directive: Hoverfocus', () => {
    let component: TestHoverFocusComponent;
    let fixture: ComponentFixture<TestHoverFocusComponent>;

    beforeEach(() => {
        TestBed.configureTestingModule({
            declarations: [HoverFocusDirective, TestHoverFocusComponent]
        });

        fixture = TestBed.createComponent(TestHoverFocusComponent);
        component = fixture.componentInstance;
        inputEl = fixture.debugElement.query(By.css('input'));
    });

    it('hovering over input', () => {
        inputEl.triggerEventHandler('mouseover', null);
        fixture.detectChanges();
        expect(inputEl.nativeElement.style.backgroundColor).toBe('blue');

        inputEl.triggerEventHandler('mouseout', null);
        fixture.detectChanges();
        expect(inputEl-nativeElement.style.background).toBe('inherit');
    });
});


======================================== Exercises ======================================

A binary gap within a positive integer N is any maximal sequence of consecutive zeros that is surrounded by ones at both ends 
in the binary representation of N.
For example, number 9 has binary representation 1001 and contains a binary gap of length 2. The number 529 has binary 
representation 1000010001 and contains two binary gaps: one of length 4 and one of length 3. The number 20 has binary 
representation 10100 and contains one binary gap of length 1. The number 15 has binary representation 1111 and has no binary gaps. The number 32 has binary representation 100000 and has no binary gaps.

Write a function:

function solution(N);

that, given a positive integer N, returns the length of its longest binary gap. The function should return 0 if N doesn't contain a binary gap.

For example, given N = 1041 the function should return 5, because N has binary representation 10000010001 and so its longest binary gap is of length 5. Given N = 32 the function should return 0, because N has binary representation '100000' and thus no binary gaps.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [1..2,147,483,647].
Copyright 2009–2019 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.


function solution(N) {
    // write your code in JavaScript (Node.js 8.9.4)
    let binaryGaps = [];
    let mayorLength = 0;
    let onePositions = [];
    const binaryNumber = N.toString(2).split('');
    
    for (let i=0; i < binaryNumber.length; i++) {
        if(binaryNumber[i] === '1') {
            onePositions.push(i);
        }
    }
    
    if (Object.keys(onePositions).length > 1) { 
        for (let i=0; i < onePositions.length; i++) {
            let gaps = binaryNumber.slice(onePositions[i] + 1, onePositions[i + 1]);
            if(gaps.length > 0) {
                binaryGaps.push(gaps.length);
            }
        }
        
        for(let num of binaryGaps) {
            if( num > mayorLength) mayorLength = num;
        } 
    }
    
    return mayorLength;
    
}

============================================================================================================
An array A consisting of N integers is given. Rotation of the array means that each element is shifted right
by one index, and the last element of the array is moved to the first place. For example, the rotation of 
array A = [3, 8, 9, 7, 6] is [6, 3, 8, 9, 7] (elements are shifted right by one index and 6 is moved to the first place).

The goal is to rotate array A K times; that is, each element of A will be shifted to the right K times.

Write a function:

function solution(A, K);

that, given an array A consisting of N integers and an integer K, returns the array A rotated K times.

For example, given

    A = [3, 8, 9, 7, 6]
    K = 3
the function should return [9, 7, 6, 3, 8]. Three rotations were made:

    [3, 8, 9, 7, 6] -> [6, 3, 8, 9, 7]
    [6, 3, 8, 9, 7] -> [7, 6, 3, 8, 9]
    [7, 6, 3, 8, 9] -> [9, 7, 6, 3, 8]
For another example, given

    A = [0, 0, 0]
    K = 1
the function should return [0, 0, 0]

Given

    A = [1, 2, 3, 4]
    K = 4
the function should return [1, 2, 3, 4]

Assume that:

N and K are integers within the range [0..100];
each element of array A is an integer within the range [−1,000..1,000].
In your solution, focus on correctness. The performance of your solution will not be the focus of the assessment.


function solution(A, K) {
    // write your code in JavaScript (Node.js 8.9.4)
    
    for (let i = 1; i <= K; i++) {
        let result = A.pop();
        A.unshift(result);
    }
    return A;
}

======================================================================================================
A non-empty array A consisting of N integers is given. The array contains an odd number of elements, 
and each element of the array can be paired with another element that has the same value, except for 
one element that is left unpaired.

For example, in array A such that:

  A[0] = 9  A[1] = 3  A[2] = 9
  A[3] = 3  A[4] = 9  A[5] = 7
  A[6] = 9
the elements at indexes 0 and 2 have value 9,
the elements at indexes 1 and 3 have value 3,
the elements at indexes 4 and 6 have value 9,
the element at index 5 has value 7 and is unpaired.
Write a function:

function solution(A);

that, given an array A consisting of N integers fulfilling the above conditions, returns the value of the unpaired element.

For example, given array A such that:

  A[0] = 9  A[1] = 3  A[2] = 9
  A[3] = 3  A[4] = 9  A[5] = 7
  A[6] = 9
the function should return 7, as explained in the example above.

Write an efficient algorithm for the following assumptions:

N is an odd integer within the range [1..1,000,000];
each element of array A is an integer within the range [1..1,000,000,000];
all but one of the values in A occur an even number of times.


function solution(A) {
    // write your code in JavaScript (Node.js 8.9.4)
    const mapping = {};
    let unpair;
    
    for (let num of A) {
        if (!mapping[num]) mapping[num] = 0;
        mapping[num]++;
    }
    
    for (let num in mapping) {
        if (mapping[num] % 2 !== 0) {
            unpair = num;
        }
    }
    
    return parseInt(unpair);
}


===============================================================================================================
A small frog wants to get to the other side of the road. The frog is currently located at position X and wants 
to get to a position greater than or equal to Y. The small frog always jumps a fixed distance, D.

Count the minimal number of jumps that the small frog must perform to reach its target.

Write a function:

function solution(X, Y, D);

that, given three integers X, Y and D, returns the minimal number of jumps from position X to a position equal 
to or greater than Y.

For example, given:

  X = 10
  Y = 85
  D = 30
the function should return 3, because the frog will be positioned as follows:

after the first jump, at position 10 + 30 = 40
after the second jump, at position 10 + 30 + 30 = 70
after the third jump, at position 10 + 30 + 30 + 30 = 100
Write an efficient algorithm for the following assumptions:

X, Y and D are integers within the range [1..1,000,000,000];
X ≤ Y.



function solution(X, Y, D) {
    // write your code in JavaScript (Node.js 8.9.4)
    let jumps = 0;
    let result = X;
    
    while (result <= Y) {
        result += D;
        jumps++;    
    }
    
    return jumps;
}


===============================================================================================================

An array A consisting of N different integers is given. The array contains integers in the range [1..(N + 1)], 
which means that exactly one element is missing.

Your goal is to find that missing element.

Write a function:

function solution(A);

that, given an array A, returns the value of the missing element.

For example, given array A such that:

  A[0] = 2
  A[1] = 3
  A[2] = 1
  A[3] = 5
the function should return 4, as it is the missing element.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [0..100,000];
the elements of A are all distinct;
each element of array A is an integer within the range [1..(N + 1)].

function solution(A) {
    // write your code in JavaScript (Node.js 8.9.4)
    let major = A[0];
    let minor = A[0];
    let missingNumber;
    
    for(let i = 0; i<A.length; i++) {
        if (A[i] < minor) minor = A[i];
        if (A[i] > major) major = A[i];
    }
    
    for(let i = minor; i<=major; i++) {
        if(A.indexOf(i) === -1) missingNumber = i;
    }
    
    return missingNumber;
}

===============================================================================================================

A non-empty array A consisting of N numbers is given. The array is sorted in non-decreasing order. 
The absolute distinct count of this array is the number of distinct absolute values among the elements of the array.

For example, consider array A such that:

  A[0] = -5
  A[1] = -3
  A[2] = -1
  A[3] =  0
  A[4] =  3
  A[5] =  6
The absolute distinct count of this array is 5, because there are 5 distinct absolute values among the elements 
of this array, namely 0, 1, 3, 5 and 6.

Write a function:

function solution(A);

that, given a non-empty array A consisting of N numbers, returns absolute distinct count of array A.

For example, given array A such that:

  A[0] = -5
  A[1] = -3
  A[2] = -1
  A[3] =  0
  A[4] =  3
  A[5] =  6
the function should return 5, as explained above.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−2,147,483,648..2,147,483,647];
array A is sorted in non-decreasing order.


function solution(A) {
    // write your code in JavaScript (Node.js 8.9.4)
    const absoluteArray = [];
    const result = {};
        
    if(A.length > 0) {
        
        for (let num of A) {
            absoluteArray.push(Math.abs(num));
        }
        
        for (let num of absoluteArray) {
            if(!result[num]) result[num] = 0;
            result[num]++;
        }
    }
    
    return Object.keys(result).length > 0 ? Object.keys(result).length : 0;
    
}

===============================================================================================================


You are given two non-empty linked lists representing two non-negative integers. 
The digits are stored in reverse order and each of their nodes contain a single digit. 
Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example:

Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.


/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    let list1String = '';
    let list2String = '';
    let result;
    let list;
    
    while(l1) {
        list1String += l1.val;        
        l1 = l1.next;
    }
    
    while(l2) {
        list2String += l2.val;
        l2 = l2.next;
    }
    
    list1String = Number(list1String.split('').reverse().join('').toString());
    list2String = Number(list2String.split('').reverse().join('').toString());
    result = (Number(list1String + list2String)).toString().split('').reverse();
    
    console.log("list1String", Number("1e+30"));
    console.log("list2String", list2String);
    console.log("result", result);
    
    list = new ListNode(result[0]);
    let head = list;
    for (let i = 1; i < result.length ;i++) {
        list.next = new ListNode(result[i]);
        list = list.next;
    }
    
    return head;
};


====================================================================================================================

This is a demo task.

Write a function:

function solution(A);

that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A.

For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5.

Given A = [1, 2, 3], the function should return 4.

Given A = [−1, −3], the function should return 1.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−1,000,000..1,000,000].

------------------------------------------
function solution(A) {

    let minor = A[0];
    let major = A[0];
    let missingNumber;
    
    if(A.length > 1) {
       for (let i=0; i < A.length;  i++) {
        if(A[i] < minor) minor = A[i];
        if(A[i] > major) major = A[i];
       }
       
        if (major < 0) major = 1;
        if (minor !== 1) minor = 1;
    
        while(!missingNumber) {
          for (let i = minor; i <= major; i++) {
            if (A.indexOf(i) === -1 ) {
                return missingNumber = i;
            }
          }
          major++;
        }

    } else if (A.length === 1) {
        if (A[A.length - 1] > 1) {
            return missinNumber = A[A.length - 1] - 1;
        } else {
            return missinNumber = A[A.length - 1] + 1;
        } 
    } else {
        return  0;
    }   
    
}

function solution(A) {

    A = A.filter(num => {
       return num > 0; 
    });
    
    
    
    if(A.length === 0) return 1;
}


---------------------------------------------
function solution(A) {
    
    let major;
    
     A = A.filter(num => {
            return num > 0; 
         });
    
    if(A.length === 0) {
        return 1;
    }
    
    if(A.length > 1) {
        major = A[0];
        
        for (let i = 1; i < A.length; i++) {
            if (A[i] > major) major = A[i];
        }
        
        
        for(let i = 1; i <= major; i++) {
            if(A.indexOf(i) === -1) {
                console.log("i", i);
            }
        }
        
    }  
    
    if (A.length === 1) {
        if (A[0] > 1) {
            return  A[0] - 1;
        } else {
            return  A[0] + 1;
        } 
    } 
    
    
}

===================================== Notes from the Book "Cracking the Code Interview" ==========================================

_________________Words which I don´t know the meaning:_________________

flawlessly: Impecablemente
The wiser: El más sabio




_________________________Notes________________________________

------> Behind the scenes (The Microsoft Interview)
1. Why do you want to work for Microsoft ?
R./ You need to show a passion for the tecnology and tools related with the Tech Brand.

------> Behind the scenes (The Amazon Interview)
1. Amazon tends to ask lot of questions about object oriented design. The bar raiser, who is
   brought in from a different team to keep the bar high.

------> Behind the scenes (The Google Interview)
1. Feedback is typically broken down into four categories (Analytical Ability, Coding, Experience and Communication)
   and you are given a score from 1.0 to 4.0 overall.

Prepare for concepts like:
    System Design 
    Memory Limits
    Bit Manipulation
The interviewers dont make the hiring decision. Their feedbacks are passed to a hiring committee

------> Behind the scenes (The Apple Interview)
1. There is 2-on-1 interviews often.

------> Behind the scenes (The Yahoo Interview)
Yahoo

Page 12 (The Yahoo Interview)